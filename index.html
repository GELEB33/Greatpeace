<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Нейронная Граница</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
            background: #0f0f1a;
            color: #e0e0ff;
            user-select: none;
        }
        #gameCanvas {
            display: block;
            background: #0f0f1a;
        }
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 16px;
            z-index: 100;
        }
        #chargeBar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 20px;
            background: rgba(50, 50, 80, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }
        #chargeFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #6a00ff, #00d4ff);
            border-radius: 10px;
            transition: width 0.3s;
        }
        #score {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 18px;
            color: #fff;
        }
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        #gameOver h1 {
            color: #ff5555;
            font-size: 24px;
        }
        #restartBtn {
            margin-top: 20px;
            padding: 10px 20px;
            background: linear-gradient(90deg, #6a00ff, #00d4ff);
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="chargeBar">
            <div id="chargeFill"></div>
        </div>
    </div>
    <div id="score">IQ: 0</div>
    <div id="gameOver">
        <h1>Нейрон погас!</h1>
        <p id="finalScore">IQ: 0</p>
        <p id="highScore">Рекорд: 0</p>
        <button id="restartBtn">Перезапустить</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const chargeFill = document.getElementById('chargeFill');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const restartBtn = document.getElementById('restartBtn');

        // Настройки игры
        const CELL_SIZE = 40;
        const NEURON_RADIUS = 15;
        const CHARGE_DRAIN = 0.2; // Скорость расхода заряда
        const CHARGE_GAIN = 25; // Сколько даёт подпитка
        const IQ_GAIN = 10; // Сколько даёт IQ

        // Размеры холста
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Игровые переменные
        let neuron = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            dx: 0,
            dy: 0,
            speed: 3,
            charge: 100,
            isAlive: true
        };

        let chargePacks = [];
        let iqPoints = [];
        let walls = [];
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;

        // Генерация лабиринта
        function generateMaze() {
            walls = [];
            const cols = Math.floor(canvas.width / CELL_SIZE) + 2;
            const rows = Math.floor(canvas.height / CELL_SIZE) + 2;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (Math.random() < 0.2 && 
                        !(i === Math.floor(cols / 2) && j === Math.floor(rows / 2))) {
                        walls.push({
                            x: i * CELL_SIZE,
                            y: j * CELL_SIZE,
                            width: CELL_SIZE,
                            height: CELL_SIZE
                        });
                    }
                }
            }
        }

        // Генерация подпитки и IQ
        function spawnItems() {
            if (Math.random() < 0.02) {
                chargePacks.push({
                    x: Math.random() * (canvas.width - 30) + 15,
                    y: Math.random() * (canvas.height - 30) + 15,
                    radius: 10
                });
            }

            if (Math.random() < 0.01) {
                iqPoints.push({
                    x: Math.random() * (canvas.width - 30) + 15,
                    y: Math.random() * (canvas.height - 30) + 15,
                    radius: 8,
                    value: IQ_GAIN
                });
            }
        }

        // Управление свайпом
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!neuron.isAlive) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            const dx = touchX - touchStartX;
            const dy = touchY - touchStartY;

            // Нормализация направления
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 10) {
                neuron.dx = (dx / distance) * neuron.speed;
                neuron.dy = (dy / distance) * neuron.speed;
            }

            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            neuron.dx = 0;
            neuron.dy = 0;
        });

        // Отрисовка нейрона (состоит из мелких кружков)
        function drawNeuron() {
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = neuron.charge > 30 ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 50, 50, 0.8)';

            // Основное тело нейрона
            ctx.beginPath();
            ctx.arc(neuron.x, neuron.y, NEURON_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = neuron.charge > 30 ? '#6a00ff' : '#ff5555';
            ctx.fill();

            // Мелкие кружки (имитация нейрона)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const distance = NEURON_RADIUS + 5;
                const x = neuron.x + Math.cos(angle) * distance;
                const y = neuron.y + Math.sin(angle) * distance;

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = neuron.charge > 30 ? '#00d4ff' : '#ff9999';
                ctx.fill();
            }

            ctx.restore();
        }

        // Отрисовка лабиринта и предметов
        function drawEnvironment() {
            // Стены
            ctx.fillStyle = '#303050';
            walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });

            // Подпитка
            ctx.fillStyle = '#00ffaa';
            chargePacks.forEach(pack => {
                ctx.beginPath();
                ctx.arc(pack.x, pack.y, pack.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // IQ-очки
            ctx.fillStyle = '#ffff00';
            iqPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('IQ', point.x - 5, point.y + 3);
            });
        }

        // Проверка столкновений
        function checkCollisions() {
            // Со стенами
            walls.forEach(wall => {
                if (
                    neuron.x + NEURON_RADIUS > wall.x &&
                    neuron.x - NEURON_RADIUS < wall.x + wall.width &&
                    neuron.y + NEURON_RADIUS > wall.y &&
                    neuron.y - NEURON_RADIUS < wall.y + wall.height
                ) {
                    // Отталкивание от стен
                    if (neuron.x < wall.x || neuron.x > wall.x + wall.width) {
                        neuron.dx *= -0.5;
                    }
                    if (neuron.y < wall.y || neuron.y > wall.y + wall.height) {
                        neuron.dy *= -0.5;
                    }
                }
            });

            // С подпиткой
            chargePacks.forEach((pack, index) => {
                const distance = Math.sqrt(
                    Math.pow(neuron.x - pack.x, 2) + 
                    Math.pow(neuron.y - pack.y, 2)
                );
                if (distance < NEURON_RADIUS + pack.radius) {
                    neuron.charge = Math.min(100, neuron.charge + CHARGE_GAIN);
                    chargePacks.splice(index, 1);
                }
            });

            // С IQ
            iqPoints.forEach((point, index) => {
                const distance = Math.sqrt(
                    Math.pow(neuron.x - point.x, 2) + 
                    Math.pow(neuron.y - point.y, 2)
                );
                if (distance < NEURON_RADIUS + point.radius) {
                    score += point.value;
                    scoreDisplay.textContent = `IQ: ${score}`;
                    iqPoints.splice(index, 1);
                }
            });
        }

        // Игровой цикл
        function gameLoop() {
            if (!neuron.isAlive) return;

            // Очистка экрана
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Обновление позиции нейрона
            neuron.x += neuron.dx;
            neuron.y += neuron.dy;

            // Границы экрана
            neuron.x = Math.max(NEURON_RADIUS, Math.min(canvas.width - NEURON_RADIUS, neuron.x));
            neuron.y = Math.max(NEURON_RADIUS, Math.min(canvas.height - NEURON_RADIUS, neuron.y));

            // Расход заряда
            neuron.charge -= CHARGE_DRAIN;
            chargeFill.style.width = `${neuron.charge}%`;

            if (neuron.charge <= 0) {
                neuron.isAlive = false;
                gameOver();
            }

            // Генерация новых элементов
            spawnItems();

            // Проверка столкновений
            checkCollisions();

            // Отрисовка
            drawEnvironment();
            drawNeuron();

            requestAnimationFrame(gameLoop);
        }

        // Конец игры
        function gameOver() {
            finalScoreDisplay.textContent = `IQ: ${score}`;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            highScoreDisplay.textContent = `Рекорд: ${highScore}`;
            gameOverScreen.style.display = 'flex';
        }

        // Перезапуск игры
        restartBtn.addEventListener('click', () => {
            neuron = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: 0,
                dy: 0,
                speed: 3,
                charge: 100,
                isAlive: true
            };
            chargePacks = [];
            iqPoints = [];
            score = 0;
            scoreDisplay.textContent = 'IQ: 0';
            gameOverScreen.style.display = 'none';
            generateMaze();
            gameLoop();
        });

        // Запуск игры
        generateMaze();
        gameLoop();
    </script>
</body>
</html>
