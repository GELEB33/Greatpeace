<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Нейронная Граница 2.0</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
            background: #0f0f1a;
            color: #e0e0ff;
            user-select: none;
        }
        #gameCanvas {
            display: block;
            background: #0f0f1a;
        }
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 16px;
            z-index: 100;
        }
        #chargeBar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 20px;
            background: rgba(50, 50, 80, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }
        #chargeFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #6a00ff, #00d4ff);
            border-radius: 10px;
            transition: width 0.3s;
        }
        #score {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 18px;
            color: #fff;
        }
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            display: none;
        }
        #gameOver h1 {
            color: #ff5555;
            font-size: 24px;
        }
        #restartBtn {
            margin-top: 20px;
            padding: 10px 20px;
            background: linear-gradient(90deg, #6a00ff, #00d4ff);
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="chargeBar">
            <div id="chargeFill"></div>
        </div>
    </div>
    <div id="score">IQ: 0</div>
    <div id="gameOver">
        <h1>Нейрон погас!</h1>
        <p id="finalScore">IQ: 0</p>
        <p id="highScore">Рекорд: 0</p>
        <button id="restartBtn">Перезапустить</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const chargeFill = document.getElementById('chargeFill');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const restartBtn = document.getElementById('restartBtn');

        // Настройки игры
        const CELL_SIZE = 60;
        const NEURON_RADIUS = 20;
        const CHARGE_DRAIN = 0.15;
        const CHARGE_GAIN = 25;
        const IQ_GAIN = 10;

        // Размеры холста
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Игровые переменные
        let neuron = {
            x: 0,
            y: 0,
            dx: 0,
            dy: 0,
            speed: 3,
            charge: 100,
            isAlive: true,
            tentacles: []
        };

        // Инициализация усиков
        for (let i = 0; i < 6; i++) {
            neuron.tentacles.push({
                length: 15 + Math.random() * 10,
                angle: (i / 6) * Math.PI * 2,
                currentAngle: (i / 6) * Math.PI * 2,
                speed: 0.05 + Math.random() * 0.1
            });
        }

        let chargePacks = [];
        let iqPoints = [];
        let walls = [];
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let cameraOffset = { x: 0, y: 0 };

        // Генерация лабиринта (бесконечного)
        function generateMazeAround(x, y) {
            const gridX = Math.floor(x / CELL_SIZE);
            const gridY = Math.floor(y / CELL_SIZE);

            for (let i = -2; i <= 2; i++) {
                for (let j = -2; j <= 2; j++) {
                    const cellX = (gridX + i) * CELL_SIZE;
                    const cellY = (gridY + j) * CELL_SIZE;

                    // Проверяем, не существует ли уже стена здесь
                    const exists = walls.some(wall => 
                        wall.x === cellX && wall.y === cellY
                    );

                    if (!exists && Math.random() < 0.15) {
                        walls.push({
                            x: cellX,
                            y: cellY,
                            width: CELL_SIZE,
                            height: CELL_SIZE
                        });
                    }
                }
            }
        }

        // Генерация подпитки и IQ
        function spawnItems() {
            if (Math.random() < 0.02) {
                chargePacks.push({
                    x: neuron.x + (Math.random() - 0.5) * canvas.width * 1.5,
                    y: neuron.y + (Math.random() - 0.5) * canvas.height * 1.5,
                    radius: 12
                });
            }

            if (Math.random() < 0.01) {
                iqPoints.push({
                    x: neuron.x + (Math.random() - 0.5) * canvas.width * 1.5,
                    y: neuron.y + (Math.random() - 0.5) * canvas.height * 1.5,
                    radius: 10,
                    value: IQ_GAIN
                });
            }
        }

        // Управление свайпом
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!neuron.isAlive) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            const dx = touchX - touchStartX;
            const dy = touchY - touchStartY;

            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 5) {
                neuron.dx = (dx / distance) * neuron.speed;
                neuron.dy = (dy / distance) * neuron.speed;
            }

            e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
            neuron.dx *= 0.5;
            neuron.dy *= 0.5;
        });

        // Отрисовка нейрона с усиками
        function drawNeuron() {
            ctx.save();
            
            // Тело нейрона
            ctx.beginPath();
            ctx.arc(0, 0, NEURON_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = neuron.charge > 30 ? '#6a00ff' : '#ff5555';
            ctx.shadowBlur = 15;
            ctx.shadowColor = neuron.charge > 30 ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 50, 50, 0.8)';
            ctx.fill();

            // Усики с физикой
            neuron.tentacles.forEach(tentacle => {
                // Плавное движение усиков
                tentacle.currentAngle += (tentacle.angle - tentacle.currentAngle) * 0.1;
                
                const endX = Math.cos(tentacle.currentAngle) * (NEURON_RADIUS + tentacle.length);
                const endY = Math.sin(tentacle.currentAngle) * (NEURON_RADIUS + tentacle.length);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(endX, endY);
                ctx.lineWidth = 2;
                ctx.strokeStyle = neuron.charge > 30 ? '#00d4ff' : '#ff9999';
                ctx.stroke();

                // Кончики усиков
                ctx.beginPath();
                ctx.arc(endX, endY, 3, 0, Math.PI * 2);
                ctx.fillStyle = neuron.charge > 30 ? '#00d4ff' : '#ff9999';
                ctx.fill();
            });

            ctx.restore();
        }

        // Отрисовка мира
        function drawEnvironment() {
            // Стены
            ctx.fillStyle = '#303050';
            walls.forEach(wall => {
                const screenX = wall.x - neuron.x + canvas.width / 2;
                const screenY = wall.y - neuron.y + canvas.height / 2;
                if (
                    screenX > -CELL_SIZE && screenX < canvas.width + CELL_SIZE &&
                    screenY > -CELL_SIZE && screenY < canvas.height + CELL_SIZE
                ) {
                    ctx.fillRect(screenX, screenY, wall.width, wall.height);
                }
            });

            // Подпитка
            chargePacks.forEach(pack => {
                const screenX = pack.x - neuron.x + canvas.width / 2;
                const screenY = pack.y - neuron.y + canvas.height / 2;
                if (
                    screenX > -50 && screenX < canvas.width + 50 &&
                    screenY > -50 && screenY < canvas.height + 50
                ) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, pack.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ffaa';
                    ctx.fill();
                }
            });

            // IQ-очки (исправлено отображение)
            iqPoints.forEach(point => {
                const screenX = point.x - neuron.x + canvas.width / 2;
                const screenY = point.y - neuron.y + canvas.height / 2;
                if (
                    screenX > -50 && screenX < canvas.width + 50 &&
                    screenY > -50 && screenY < canvas.height + 50
                ) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, point.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffff00';
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('IQ', screenX, screenY);
                }
            });
        }

        // Проверка столкновений
        function checkCollisions() {
            // Со стенами
            walls.forEach(wall => {
                if (
                    Math.abs(neuron.x - wall.x - CELL_SIZE / 2) < NEURON_RADIUS + CELL_SIZE / 2 &&
                    Math.abs(neuron.y - wall.y - CELL_SIZE / 2) < NEURON_RADIUS + CELL_SIZE / 2
                ) {
                    // Отталкивание
                    const angle = Math.atan2(neuron.y - wall.y - CELL_SIZE / 2, neuron.x - wall.x - CELL_SIZE / 2);
                    neuron.dx = Math.cos(angle) * neuron.speed * 0.7;
                    neuron.dy = Math.sin(angle) * neuron.speed * 0.7;
                }
            });

            // С подпиткой
            chargePacks.forEach((pack, index) => {
                const distance = Math.sqrt(
                    Math.pow(neuron.x - pack.x, 2) + 
                    Math.pow(neuron.y - pack.y, 2)
                );
                if (distance < NEURON_RADIUS + pack.radius) {
                    neuron.charge = Math.min(100, neuron.charge + CHARGE_GAIN);
                    chargePacks.splice(index, 1);
                }
            });

            // С IQ
            iqPoints.forEach((point, index) => {
                const distance = Math.sqrt(
                    Math.pow(neuron.x - point.x, 2) + 
                    Math.pow(neuron.y - point.y, 2)
                );
                if (distance < NEURON_RADIUS + point.radius) {
                    score += point.value;
                    scoreDisplay.textContent = `IQ: ${score}`;
                    iqPoints.splice(index, 1);
                }
            });
        }

        // Игровой цикл
        function gameLoop() {
            if (!neuron.isAlive) return;

            // Очистка экрана
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Обновление позиции нейрона
            neuron.x += neuron.dx;
            neuron.y += neuron.dy;

            // Генерация новых участков лабиринта
            generateMazeAround(neuron.x, neuron.y);

            // Расход заряда
            neuron.charge -= CHARGE_DRAIN;
            chargeFill.style.width = `${neuron.charge}%`;

            if (neuron.charge <= 0) {
                neuron.isAlive = false;
                gameOver();
            }

            // Обновление углов усиков (движение)
            neuron.tentacles.forEach(tentacle => {
                tentacle.angle = Math.atan2(-neuron.dy, -neuron.dx) + Math.PI + (Math.random() - 0.5) * 0.5;
            });

            // Генерация новых элементов
            spawnItems();

            // Проверка столкновений
            checkCollisions();

            // Смещение камеры (центрирование на нейроне)
            ctx.save();
            ctx.translate(canvas.width / 2 - neuron.x, canvas.height / 2 - neuron.y);

            // Отрисовка мира
            drawEnvironment();

            // Отрисовка нейрона (относительно камеры)
            ctx.save();
            ctx.translate(neuron.x, neuron.y);
            drawNeuron();
            ctx.restore();

            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // Конец игры
        function gameOver() {
            finalScoreDisplay.textContent = `IQ: ${score}`;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            highScoreDisplay.textContent = `Рекорд: ${highScore}`;
            gameOverScreen.style.display = 'flex';
        }

        // Перезапуск игры
        restartBtn.addEventListener('click', () => {
            neuron = {
                x: 0,
                y: 0,
                dx: 0,
                dy: 0,
                speed: 3,
                charge: 100,
                isAlive: true,
                tentacles: []
            };

            for (let i = 0; i < 6; i++) {
                neuron.tentacles.push({
                    length: 15 + Math.random() * 10,
                    angle: (i / 6) * Math.PI * 2,
                    currentAngle: (i / 6) * Math.PI * 2,
                    speed: 0.05 + Math.random() * 0.1
                });
            }

            chargePacks = [];
            iqPoints = [];
            walls = [];
            score = 0;
            scoreDisplay.textContent = 'IQ: 0';
            gameOverScreen.style.display = 'none';
            generateMazeAround(0, 0);
            gameLoop();
        });

        // Запуск игры
        generateMazeAround(0, 0);
        gameLoop();
    </script>
</body>
</html>
